# Search API

You can also interface with Morsels through its API.

## Setup

Under the global `morsels` variable, you can instantiate an instance of the `Searcher` class.

```ts
const searcher = new morsels.Searcher({
    url: 'https://... the index output directory ...'
});
```

The constructor parameter uses the same options as `morsels.initMorsels`, you can refer to this [page](./search_configuration.md#search-functionality-options) for the other available options.

**Initialising States**

Setup is also async and and mostly proceeds in the WebWorker. You can  use the `setupPromise` and `isSetupDone` interfaces to optionally show UI initialising states.

```ts
searcher.setupPromise.then(() => {
    assert(searcher.isSetupDone, true);
});
```

## Querying

Next, you can create a `Query` object, which obtains and ranks the result set. 

```ts
const query: Query = await searcher.runQuery('sunny weather');
```

The `Query` object follows this interface.

```ts
interface Query {
    /**
     * Original query string.
     */
    public readonly query: string,
    /**
     * Total number of results.
     */
    public readonly resultsTotal: number,
    /**
     * Returns the next top N results.
     */
    public readonly getNextN: (n: number) => Promise<Result[]>,
    /**
     * Freeing a query manually is required since its results live in the WebWorker.
     */
    public readonly free: () => void,
}
```

## Loading Document Texts

Running a query alone probably isn't very useful. You can get a `Result` object using the `getNextN` function.

```ts
const results: Result[] = await query.getNextN(10);
```

A `Result` object stores the fields of the indexed document. The fields are stored as an array of `[fieldName, fieldText]` pairs in the order they were seen.

```ts
const documentText: [string, string][] = results[0].fields;

[
  ['_relative_fp', 'relative_file_path/of_the_file/from_the_folder/you_indexed'],
  ['title', 'README'],
  ['h1', 'README'],
  ['headingLink', 'description'],
  ['heading', 'Description'],
  ['body', 'Morsels is a client-side search solution made for static sites, depending on a pre-built index generated by a CLI tool. Some similar tools in this space are Stork and TinySearch. Morsels does the same, with a focus on providing a more feature rich and relevant search experience, while remaining easy to get started with for common use cases (e.g. single domain static sites).'],
  // ... more headingLink, heading, body fields ...
]
```

This ordered model is more complex than a regular key-value store, but enables the content hierarchy you see in Morsels' UI: *Title > Heading > Text under heading*

## Memory Management

As Morsels uses a WebWorker to run things, you would also need to perform some memory management.

Once you are done with a `Query` (e.g. if a new query was run), call `free()` on the `query` object.

```ts
query.free();
```

Search interfaces usually live for the entire lifetime of the application. If you need to do so however, you should also free the `Searcher` instance:

```ts
searcher.free();
```

## Convenience Methods

A `Result` object also exposes 2 other convenience functions that may be useful to help deal with the positional format of the field stores.

### 1. Retrieving Singular Fields as KV Stores

Certain fields will only occur once in every document (e.g. titles, `<h1>` tags). To retrieve these easily, you can use the `getKVFields` method:

```ts
// Assign the fields you want populated as null, then pass it into the method
const fields = { link: null, _relative_fp: null, title: null, h1: null };
result.getKVFields(fields);
```

Only the first `[fieldName, fieldText]` pair for each field will be populated into the `fields` object.

**Tip: Constructing a Document Link**

If you haven't manually added any links to your source documents, you can use the `_relative_fp` field to construct one, by concatenating it to a base URL for example. Any links added via the [`data-morsels-link`](./linking_to_others.md) attribute are also available under the `link` field.

### 2. Highlighting and Linking 'Heading' and 'Body' Excerpts

To establish the relationship between adjacent *heading*, *body* and *headingLink* fields in particular, you can call the `getHeadingBodyExcerpts` method.

```ts
const bodyHeadingMatchResults: Segment[] = result.getHeadingBodyExcerpts();
```

This returns an array of *Segments*. Each *Segment* represents a chunk of `fieldText`.

**Sorting and Choosing Segments**

```ts
interface Segment {
  /**
   * 'heading' types come from 'heading' fields,
   * while 'body' and 'heading-body' types come from 'body' fields.
   */
  type: 'heading' | 'body' | 'heading-body',

  /**
   * This will only be present if type === 'heading-body',
   * and points to another Segment with type === 'heading'.
   */
  heading?: Segment,

  /**
   * This will only be present if type === 'heading' | 'heading-body',
   * and points to the heading's id, if any.
   */
  headingLink?: string,

  /**
   * How many terms were matched in this segment.
   */
  numTerms: number,
}
```

You would select and display a **few best segments** only. To rank them, you could for example first priortise segments with a greater `numTerms` matched, then tie-break by the `type` of the segment. This is up to your UI!

**Text Highlighting**

```ts
interface Segment {
  ...

  highlight: (addEllipses: boolean = true) => (string | HTMLElement)[],
  highlightHTML: (addEllipses: boolean = true) => string,

  window: { pos: number, len: number }[],   // Character position and length
  text: string,                             // original string
}

```

You can perform text highlighting manually using the original `text` and the closest `window` of term matches, or automatically using the `highlight()` and `highlightHTML()` methods.

The `highlight()` method wraps term matches in a `<mark>` element, truncates surrounding text, and adds leading and trailing ellipses elements. An example output is as follows:

```ts
[
  '<span class="morsels-ellipses"> ... </span>',
  ' text before ',
  '<mark class="morsels-highlight">highlighted</mark>',
  ' text after ',
  '<span class="morsels-ellipses"> ... </span>',
]
```

To interact with the `(string | HTMLElement)[]` output safely (strings are unescaped) and efficiently, you could use the DOM APIs `.append(...)` and `.textContent = ...` in particular.

You can also call `highlightHTML()` which returns a single escaped HTML string. This is less efficient, but more convenient to use directly via `.innerHTML = '...'`.
