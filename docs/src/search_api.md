# Search API

You can also interface with Morsels through its API.

## Setup

Under the global `morsels` variable, you can instantiate an instance of the `Searcher` class.

```ts
const searcher = new morsels.Searcher({
    url: 'https://... the index output directory ...'
});
```

The constructor parameter uses the same options as `morsels.initMorsels`, see this [page](./search_configuration.md#search-functionality-options) for the other available options.

Setup is also async and and mostly proceeds in the WebWorker. You can  use the `setupPromise` and `isSetupDone` interfaces to show UI initialising states for example.

```ts
searcher.setupPromise.then(() => {
    assert(searcher.isSetupDone, true);
});
```

## Querying

Next, you can run a query like so: 

```ts
// Create a Query object, which obtains and ranks the result set.
const query: Query = await searcher.runQuery('sunny weather');
```

This returns a `Query` object.

```ts
interface Query {
    /**
     * Original query string.
     */
    public readonly query: string,
    /**
     * Total number of results.
     */
    public readonly resultsTotal: number,
    /**
     * Returns the next N results.
     */
    public readonly getNextN: (n: number) => Promise<Result[]>,
    /**
     * Freeing a query manually is required since its results live in the WebWorker.
     */
    public readonly free: () => void,
}
```

## Loading Document Texts

Running a query alone probably isn't very useful. You can get a `Result` object using the `getNextN` function.

```ts
const results: Result[] = await query.getNextN(10);
```

A `Result` object stores the fields of the indexed document. The fields are stored as an array of field name, field text pairs in the order they were seen.

```ts
const documentText: [string, string][] = results[0].fields;

// Under the default setup for fields,
// indexing a HTML document would net you something like this:
[
  ['_relative_fp', 'relative_file_path/of_the_file/from_the_folder/you_indexed'],
  ['title', 'README'],
  ['h1', 'README'],
  ['headingLink', 'description'],
  ['heading', 'Description'],
  ['body', 'Morsels is a client-side search solution made for static sites, depending on a pre-built index generated by a CLI tool. Some similar tools in this space are Stork and TinySearch. Morsels does the same, with a focus on providing a more feature rich and relevant search experience, while remaining easy to get started with for common use cases (e.g. single domain static sites).'],
  // ... more headingLink, heading, body fields ...
]
```

This ordered model is more complex than a regular key-value store, but enables the content hierarchy you see in Morsels' UI: *Title > Heading > Text under heading*

A `Result` object also exposes 2 other convenience functions that may be useful to help deal with this format.

### Retrieving Fields as KV Stores

Certain fields will only occur once in every document (e.g. titles, `<h1>` tags). To retrieve these easily, you can use the `getKVFields` function like so:

```ts
// Assign the fields you want populated as null, then pass it into the function
const fields = { link: null, _relative_fp: null, title: null, h1: null };
result.getKVFields(fields);
```

Only the first `[fieldName, fieldText]` field seen will be populated into the `fields` object.

**Tip: Constructing a Document Link**

If you haven't manually added any links to your source documents, you can use the `_relative_fp` field to construct one. Any links added via the [`data-morsels-link`](./linking_to_others.md) attribute are available under the `link` field.

### Highlighting and Linking 'Heading' and 'Body' Excerpts

To establish the relationship between adjacent *heading* and *body* fields in particular, you can call the `getHeadingBodyExcerpts` method.

```ts
const bodyHeadingMatchResults: Segment[] = result.getHeadingBodyExcerpts();
```

This returns an array of *Segments*.

```ts
interface Segment {
  type: 'heading' | 'body' | 'heading-body',

  // This will only be present if type === 'heading-body',
  // and points to another Segment with type === 'heading'.
  heading?: Segment,

  // This will only be present if type === 'heading' | 'heading-body',
  // and points to the heading's id, if any.
  headingLink?: string,

  // How many terms were matched in this segment
  numTerms: number,

  // -------------------------------------------------
  // Properties for text highlighting

  // Automatically highlight this segment
  highlight: () => (string | HTMLElement)[],

  // Use these 2 properties for manual highlighting.
  window: { pos: number, len: number }[],  // Character position and length
  text: string,                            // Original string
  // -------------------------------------------------
}
```

To perform text **highlighting**, you could implement it manually using the original `text` and the closest `window` of term matches.

Alternatively, calling `highlight` returns Morsels' default formatting, which wraps matches in a `<mark>` element, truncates surrounding text, and adds leading and trailing ellipses elements. An example output is as follows:

```ts
[
  '<span class="morsels-ellipses"> ... </span>',
  ' text before ',
  '<mark class="morsels-highlight">highlighted</mark>',
  ' text after ',
  '<span class="morsels-ellipses"> ... </span>',
]
```

You would also likely want to display the **best few segments** only. To rank them, you could for example first priortise segments with a greater `numTerms` matched, then tie-break by the `type` of the segment. 

## Memory Management

As Morsels uses a WebWorker to run things, you would also need to perform some memory management.

Once you are done with a `Query` (e.g. if a new query was run), call `free()` on the `query` object.

```ts
query.free();
```

Search interfaces usually live for the entire lifetime of the application. If you need to do so however, you should also free the `Searcher` instance:

```ts
searcher.free();
```
